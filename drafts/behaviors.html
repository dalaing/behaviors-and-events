<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Behaviors</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../css/custom.css">
        <link rel="stylesheet" href="../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - A Series on Behaviors and Events" href="../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - A series on behaviours and events" href="../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../">A Series on Behaviors and Events</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../drafts/behaviors.html">Behaviors</a></h3>
    </div>
    <div class="panel-body">
        <p><a href="./echo.html">Previously</a> we developed a simple command line program and refactored it to make parts of it more reusable and testable.</p>
<h1 id="behaviors">Behaviors</h1>
<p>The next piece of the <code>FRP</code> puzzle is behaviors. Where events are only defined at particular points in time, behaviors are defined for all points of time.</p>
<p>The documentation mentions that the semantics of an <code>Behavior a</code> allows you to view it as being similar to <code>Time -&gt; a</code>. In contrast to events, behaviors have values for every point in time.</p>
<p>This lets us use behaviors to model program state, since the program state is a value that changes over time. We can also pass them as arguments as something like a ‘live variable’ or a ‘first-class observer’. All in good time.</p>
<p>The type in <code>reactive-banana</code> is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Behavior</span> a</code></pre></div>
<p>and it has a <code>Functor</code> instance and an <code>Applicative</code> instance.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Behavior</span>
<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Behavior</span></code></pre></div>
<p>The <code>Applicative</code> instance means that we can create a behavior that has a constant value across all times using <code>pure</code>, and we can stitch them together using <code>&lt;*&gt;</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- bInt and bString defined elsewhere</span>

<span class="ot">bBool ::</span> <span class="dt">Behavior</span> <span class="dt">Bool</span>
bBool <span class="fu">=</span> pure <span class="dt">True</span>

<span class="ot">bTriple ::</span> <span class="dt">Behavior</span> (<span class="dt">Int</span>, <span class="dt">String</span>, <span class="dt">Bool</span>)
bTriple <span class="fu">=</span> (,,) <span class="fu">&lt;$&gt;</span> bInt <span class="fu">&lt;*&gt;</span> bString <span class="fu">&lt;*&gt;</span> bBool</code></pre></div>
<p>The more common (and more interesting) way to create a behavior is with <code>stepper</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stepper ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> m (<span class="dt">Behavior</span> a)
stepper x eNext <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>This will create a <code>Behavior</code> that starts with the value <code>x</code>, and then changes its to the value the event <code>eNext</code> every time that event occurs. This change will not be observable until the next logical clock tick <em>after</em> the event <code>eNext</code>.</p>
The time delay for the change stands out in the example diagrams:
<table>
<tr>
<td width="50%">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">holder ::</span> <span class="dt">MonadMoment</span> m 
       <span class="ot">=&gt;</span> <span class="dt">Event</span> <span class="dt">Colour</span> 
       <span class="ot">-&gt;</span> m (<span class="dt">Behavior</span> <span class="dt">Colour</span>)
holder eInput <span class="fu">=</span> <span class="kw">do</span>
  eOutput <span class="ot">&lt;-</span>
    stepper <span class="dt">Blue</span> eInput
  return eOutput</code></pre></div>
</td>
<td width="50%">
<img src="../images/stepper.png" /><br />

</td>
</tr>
</table>
<p>If we’re viewing this as state manipulation, then we should be able to use a <code>State</code> monad simile. Imagine that we’ve identified a handful of conditions that would cause us to use <code>put</code> at various times and with various values. We already have the tools to combine all of those calls to <code>put</code> into the <code>eInput</code> event - at which point we could use <code>stepper</code> to create a <code>Behavior</code> that models all of the changes to this particular piece of state over time.</p>
<p>We commonly build <code>Behavior</code>s using <code>Event</code>s, and it turns out that we also sample <code>Behavior</code>s using <code>Event</code>s. The <code>Event</code> is what give us the logical clock tick to use to sample the <code>Behavior</code>.</p>
<p>This is commonly done with some infix operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&lt;@&gt;) ::</span> <span class="dt">Behavior</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> b
<span class="ot">(&lt;@)  ::</span> <span class="dt">Behavior</span> b        <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> b </code></pre></div>
<p>These are analogues of <code>&lt;*&gt;</code> and <code>&lt;*</code> from <code>Applicative</code>. Since behaviour has an <code>Applicative</code> instance, it means we can do things like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">&lt;$&gt;</span> bBehavior1 <span class="fu">&lt;*&gt;</span> bBehavior2 <span class="fu">&lt;@&gt;</span> eEventWithStuffTheFunctionNeeds</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">&lt;$&gt;</span> bBehavior1 <span class="fu">&lt;*&gt;</span> bBehavior2 <span class="fu">&lt;@</span> eEventThatIsJustActingAsATrigger</code></pre></div>
<p>We can demonstrate these pictorially.</p>
Sometimes we want to involve the value of the <code>Event</code>:
<table>
<tr>
<td width="50%">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mixer ::</span> <span class="dt">Behavior</span> <span class="dt">Colour</span> 
      <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Colour</span>
      <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Colour</span>
mixer bInput eInput <span class="fu">=</span>
  <span class="kw">let</span>
    eOutput <span class="fu">=</span> 
      mix <span class="fu">&lt;$&gt;</span> 
        bInput <span class="fu">&lt;@&gt;</span> 
        eInput
  <span class="kw">in</span>
    eOutput</code></pre></div>
</td>
<td width="50%">
<img src="../images/sample-mix.png" /><br />

</td>
</tr>
</table>
and sometimes we don’t:
<table>
<tr>
<td width="50%">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tagger ::</span> <span class="dt">Behavior</span> <span class="dt">Colour</span> 
       <span class="ot">-&gt;</span> <span class="dt">Event</span> ()
       <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Colour</span>
tagger bInput eInput <span class="fu">=</span>
  <span class="kw">let</span>
    eOutput <span class="fu">=</span> 
      bInput <span class="fu">&lt;@</span> eInput
  <span class="kw">in</span>
    eOutput</code></pre></div>
</td>
<td width="50%">
<img src="../images/sample-const.png" /><br />

</td>
</tr>
</table>
<p>If we were squinting that the <code>Event</code> we used with <code>stepper</code> and imagining that it was the aggregation of all of our uses of <code>put</code> in the <code>State</code> monad, then we can view the <code>Event</code> we use with <code>&lt;@</code> as the aggregation of some uses of <code>get</code>.</p>
<p>The last major use of <code>Behavior</code>s is to filter <code>Event</code>s, where the filter condition that changes over time:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">whenE       ::</span> <span class="dt">Behavior</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a
<span class="ot">filterApply ::</span> <span class="dt">Behavior</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</code></pre></div>
Assuming <code>True</code> is dark gray and <code>False</code> is light gray, we would have:
<table>
<tr>
<td width="50%">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sifter ::</span> <span class="dt">Behavior</span> <span class="dt">Bool</span> 
       <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Colour</span>
       <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Colour</span>
sifter bInput eInput <span class="fu">=</span>
  <span class="kw">let</span>
    eOutput <span class="fu">=</span> 
      whenE bInput eInput
  <span class="kw">in</span>
    eOutput</code></pre></div>
</td>
<td width="50%">
<img src="../images/whenE.png" /><br />

</td>
</tr>
</table>
<p>What has this given us? It has given us a way to manage state inside an FRP system.</p>
<p>We have a lot of freedom here.</p>
<p>We can develop several <code>Behavior</code>s and combine them together with the <code>Applicative</code> typeclass. The <code>Behavior</code>s don’t need to know anything about each other - maybe they’re all change at the same points in time, maybe they’re changing at complete distinct points in time.</p>
<p>We can sample these <code>Behavior</code>s with any <code>Event</code>s that we have, and again we don’t know and don’t care if the points in time the <code>Event</code>s fire at correspond to the points in time where the <code>Behavior</code> is changing.</p>
<p>The independence and composability of the pieces are what makes FRP fun to work with.</p>
<h2 id="an-example">An example</h2>
<p>We’re going to model a user logging in and logging out of a website. The goal is track whether they are currently logged in or logged out.</p>
<p>We’ll start with a data type for the login state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LoginState</span> <span class="fu">=</span> 
    <span class="dt">LoggedIn</span>
  <span class="fu">|</span> <span class="dt">LoggedOut</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>and a pair of data types for the inputs and outputs of our component:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LoginInputs</span> <span class="fu">=</span> <span class="dt">LoginInputs</span> {
<span class="ot">    lieLogIn  ::</span> <span class="dt">Event</span> ()
  ,<span class="ot"> lieLogOut ::</span> <span class="dt">Event</span> ()
  }
  
<span class="kw">data</span> <span class="dt">LoginOutputs</span><span class="ot"> ::</span> <span class="dt">LoginOutputs</span> {
<span class="ot">    lobState ::</span> <span class="dt">Behavior</span> <span class="dt">LoginState</span>
  }</code></pre></div>
<p>From there we just need to use <code>leftmost</code> to combine the events and <code>stepper</code> to turn them into a behavior:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">LogInInputs</span> <span class="ot">-&gt;</span> m <span class="dt">LoginOutputs</span>
logInHandler (<span class="dt">LogInEvents</span> eLogIn eLogOut) <span class="fu">=</span> <span class="kw">do</span>
  bState <span class="ot">&lt;-</span> stepper <span class="dt">LoggedOut</span> <span class="fu">.</span> leftmost <span class="fu">$</span> [
      <span class="dt">LoggedIn</span>  <span class="fu">&lt;$</span> eLogIn                                      <span class="co">-- (1)</span>
    , <span class="dt">LoggedOut</span> <span class="fu">&lt;$</span> eLogOut                                     <span class="co">-- (2)</span>
    ]
  return <span class="fu">$</span> <span class="dt">LoginOutputs</span> bState</code></pre></div>
<p>Notes:</p>
<ol style="list-style-type: decimal">
<li>Change the state to <code>LoggedIn</code> when the user logs in.</li>
<li>Change the state to <code>LoggedOut</code> when the user logs out.</li>
</ol>
<p>All is well at this point.</p>
<p>If we want to add more meat to the problem, we can disallow logging in while already logged in or logging out while already logged out.</p>
<p>We add a data type for the kinds of errors we might see:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LoginError</span> <span class="fu">=</span>
    <span class="dt">AlreadyLoggedIn</span>
  <span class="fu">|</span> <span class="dt">NotLoggedIn</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We also write some helper functions to work out whether we should change state or signal that an error has occurred:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logIn ::</span> <span class="dt">LogInState</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">LoginError</span> <span class="dt">LoginState</span>
logIn <span class="dt">LoggedIn</span>  <span class="fu">=</span> <span class="dt">Left</span> <span class="dt">AlreadyLoggedIn</span>
logIn <span class="dt">LoggedOut</span> <span class="fu">=</span> <span class="dt">Right</span> <span class="dt">LoggedIn</span>

<span class="ot">logOut ::</span> <span class="dt">LogInState</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">LoginError</span> <span class="dt">LoginState</span>
logOut <span class="dt">LoggedOut</span> <span class="fu">=</span> <span class="dt">Left</span> <span class="dt">NotLoggedIn</span>
logOut <span class="dt">LoggedIn</span>  <span class="fu">=</span> <span class="dt">Right</span> <span class="dt">LoggedOut</span></code></pre></div>
<p>We add an event signaling that an error has occurred to our output:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LoginOutputs</span><span class="ot"> ::</span> <span class="dt">LoginOutputs</span> {
<span class="ot">    lobState ::</span> <span class="dt">Behavior</span> <span class="dt">LoginState</span>
  ,<span class="ot"> loeError ::</span> <span class="dt">Event</span> <span class="dt">LoginError</span>
  }</code></pre></div>
<p>and we’re ready to begin.</p>
<p>I’m going to go slowly through this part.</p>
<p>We’re going to make use of an extension that gets used a bit in the FRP world:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# RecursiveDo #-}</span></code></pre></div>
<p>This allows us to use <code>mdo</code> instead of <code>do</code> to indicate that we want to use value recursion:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> <span class="dt">LoginInputs</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> <span class="dt">LoginOutputs</span>
logInHandler (<span class="dt">LoginInputs</span> eLogIn eLogOut) <span class="fu">=</span> mdo
  <span class="fu">...</span>
  return <span class="fu">$</span> <span class="dt">LoginOutputs</span> <span class="fu">???</span> <span class="fu">???</span></code></pre></div>
<p>We want to start the user as <code>LoggedOut</code>. It should be possible to use <code>stepper</code> to build our <code>Behavior LoginState</code> from that and some <code>Event</code>, which we’ll deal with later:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> <span class="dt">LoginInputs</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> <span class="dt">LoginOutputs</span>
logInHandler (<span class="dt">LoginInputs</span> eLogIn eLogOut) <span class="fu">=</span> mdo
  bState <span class="ot">&lt;-</span> stepper <span class="dt">LoggedOut</span> <span class="fu">???</span>
  <span class="fu">...</span>
  return <span class="fu">$</span> <span class="dt">LoginOutputs</span> bState <span class="fu">???</span></code></pre></div>
<p>At this point we have one of our outputs.</p>
<p>Now we can sample <code>bLoginState</code> in order to bring our helper functions into play:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> <span class="dt">LoginInputs</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> <span class="dt">LoginOutputs</span>
logInHandler (<span class="dt">LoginInputs</span> eLogIn eLogOut) <span class="fu">=</span> mdo
  bState <span class="ot">&lt;-</span> stepper <span class="dt">LoggedOut</span> <span class="fu">???</span>
  <span class="fu">???</span> leftmost <span class="fu">$</span> [
      logIn  <span class="fu">&lt;$&gt;</span> bState <span class="fu">&lt;@</span> eLogIn
    , logOut <span class="fu">&lt;$&gt;</span> bState <span class="fu">&lt;@</span> eLogOut
    ]
  return <span class="fu">$</span> <span class="dt">LoginOutputs</span> bState <span class="fu">???</span></code></pre></div>
<p>which will give us an <code>Event (Either LoginError LoginState)</code>.</p>
<p>That can be split into an event for the case where there was an error and an event for the case where we should change the state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> <span class="dt">LoginInputs</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> <span class="dt">LoginOutputs</span>
logInHandler (<span class="dt">LoginInputs</span> eLogIn eLogOut) <span class="fu">=</span> mdo
  bState <span class="ot">&lt;-</span> stepper <span class="dt">LoggedOut</span> <span class="fu">???</span>
  <span class="kw">let</span> (eLoginError, eLoginState) <span class="fu">=</span> split <span class="fu">.</span> leftmost <span class="fu">$</span> [
        logIn  <span class="fu">&lt;$&gt;</span> bState <span class="fu">&lt;@</span> eLogIn
      , logOut <span class="fu">&lt;$&gt;</span> bState <span class="fu">&lt;@</span> eLogOut
      ]
  return <span class="fu">$</span> <span class="dt">LoginOutputs</span> bState eLoginError</code></pre></div>
<p>which gives us our second output.</p>
<p>Now we make use of the value recursion, and use <code>eLoginState</code> as the event that drives the call to <code>stepper</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> <span class="dt">LoginInputs</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> <span class="dt">LoginOutputs</span>
logInHandler (<span class="dt">LoginInputs</span> eLogIn eLogOut) <span class="fu">=</span> mdo
  bState <span class="ot">&lt;-</span> stepper <span class="dt">LoggedOut</span> eLoginState
  <span class="kw">let</span>
    (eLoginError, eLoginState) <span class="fu">=</span> split <span class="fu">.</span> leftmost <span class="fu">$</span> [
        logIn  <span class="fu">&lt;$&gt;</span> bState <span class="fu">&lt;@</span> eLogIn
      , logOut <span class="fu">&lt;$&gt;</span> bState <span class="fu">&lt;@</span> eLogOut
      ]
  return <span class="fu">$</span> <span class="dt">LoginOutputs</span> bState eLoginError</code></pre></div>
<p>This creates a loop in our event network, but everything will be well behaved if we only recursive refer to <code>Behavior</code>s via <code>Event</code>s or to <code>Event</code>s via <code>Behavior</code>s. The delays in the updates to <code>Behavior</code>s appear to be part of the reason that this works out so well.</p>
<p>Value recursion can take a little while to wrap your head around, but it’s very helpful for expressing interesting problems elegantly and concisely.</p>
<p>There are two variations on the above that are worth pointing out.</p>
<p>If we want to use <code>MonadMoment</code>, we also need to use a <code>MonadFix</code> constraint:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> (<span class="dt">MonadMoment</span> m, <span class="dt">MonadFix</span> m) <span class="ot">=&gt;</span> <span class="dt">LoginInputs</span> <span class="ot">-&gt;</span> m <span class="dt">LoginOutputs</span></code></pre></div>
<p>If we want to limit the scope of the value recursion, we can use the <code>rec</code> keyword instead of <code>mdo</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logInHandler ::</span> <span class="dt">LoginInputs</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> <span class="dt">LoginOutputs</span>
logInHandler (<span class="dt">LoginInputs</span> eLogIn eLogOut) <span class="fu">=</span> <span class="kw">do</span>
  rec
    bLogInState <span class="ot">&lt;-</span> stepper <span class="dt">LoggedOut</span> eLogInState
    <span class="kw">let</span>
      (eLogInError, eLogInState) <span class="fu">=</span> split <span class="fu">.</span> leftmost <span class="fu">$</span> [
          logIn  <span class="fu">&lt;$&gt;</span> bLogInState <span class="fu">&lt;@</span> eLogIn
        , logOut <span class="fu">&lt;$&gt;</span> bLogInState <span class="fu">&lt;@</span> eLogOut
        ]
  <span class="kw">let</span> 
    notInScopeOfTheRecursion <span class="fu">=</span> <span class="dt">True</span>
  return <span class="fu">$</span> <span class="dt">LoginOutputs</span> bLogInState eLogInError</code></pre></div>
<h2 id="message-history">Message history</h2>
<h5 id="the-code-for-this-section-is-here"><a href="https://github.com/dalaing/behaviors-and-events/tree/master/code/talk/src/Part3/">(The code for this section is here)</a></h5>
<p>Let’s use <code>stepper</code>, <code>&lt;@&gt;</code> and <code>&lt;@</code> to demonstrate what we can do with behaviors.</p>
<p>As a reminder, our previous take on message handling was pretty boring:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MessageInput</span>  <span class="fu">=</span> <span class="dt">MessageInput</span>  {<span class="ot"> mieRead  ::</span> <span class="dt">Event</span> <span class="dt">String</span> }
<span class="kw">data</span> <span class="dt">MessageOutput</span> <span class="fu">=</span> <span class="dt">MessageOutput</span> {<span class="ot"> moeWrite ::</span> <span class="dt">Event</span> <span class="dt">String</span> }

<span class="ot">handleMessage ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> m <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage) <span class="fu">=</span> <span class="kw">do</span>
  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eMessage</code></pre></div>
<h3 id="the-last-message">The last message</h3>
<p>We’ll spice that up by printing the last message that was echoed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- see Part3.Example1</span>
<span class="ot">handleMessage ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> m <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage) <span class="fu">=</span> <span class="kw">do</span>
  bMessages <span class="ot">&lt;-</span> stepper <span class="st">&quot;&quot;</span> eMessage
  <span class="kw">let</span>
    format l m <span class="fu">=</span> m <span class="fu">++</span> <span class="st">&quot; (last message: &quot;</span> <span class="fu">++</span> l <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    eOut <span class="fu">=</span> format <span class="fu">&lt;$&gt;</span> bMessages <span class="fu">&lt;@&gt;</span> eMessage
  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eOut</code></pre></div>
<p>We’re using <code>stepper</code> to keep the most recently seen message around so that we can sample it later on. The updates to <code>stepper</code> are being driven by <code>eMessage</code>, and won’t be seen until the next transaction. By using <code>eMessage</code> to sample <code>bMessages</code> we’re grabbing the value of <code>bMessages</code> at the moment before it gets updated by <code>eMessage</code>.</p>
<p>This is how we manage to use the behavior to get hold of the last message that we saw.</p>
<h3 id="the-length-of-the-last-message">The length of the last message</h3>
<p>We’ve already got the last message on the screen, so maybe displaying the length of the last message would be more interesting:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- see Part3.Example2</span>
<span class="ot">handleMessage ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> m <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage) <span class="fu">=</span> <span class="kw">do</span>
  bMessages <span class="ot">&lt;-</span> stepper <span class="st">&quot;&quot;</span> eMessage
  <span class="kw">let</span>
    bLastLength <span class="fu">=</span> length <span class="fu">&lt;$&gt;</span> bMessages
    format l m <span class="fu">=</span> m <span class="fu">++</span> <span class="st">&quot; (last message length: &quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    eOut <span class="fu">=</span> format <span class="fu">&lt;$&gt;</span> bLastLength <span class="fu">&lt;@&gt;</span> eMessage
  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eOut</code></pre></div>
<p>It also shows that I’m not lying about the <code>Functor</code> instance.</p>
<h3 id="all-of-the-previous-messages">All of the previous messages</h3>
<p>We use another function to do more interesting things with behaviors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">accumB ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Behavior</span> a) 
accumB x eFunction <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
This is like a combination of <code>stepper</code> and <code>accumE</code>:
<table>
<tr>
<td width="50%">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toggler ::</span> <span class="dt">MonadMoment</span> m 
        <span class="ot">=&gt;</span> <span class="dt">Event</span> ()
        <span class="ot">-&gt;</span> m (<span class="dt">Behavior</span> <span class="dt">Colour</span>)
toggler eInput <span class="fu">=</span> <span class="kw">do</span>
  eOutput <span class="ot">&lt;-</span> 
    accumB <span class="dt">Red</span> (flip <span class="fu">&lt;$</span> eInput)
  return eOutput</code></pre></div>
</td>
<td width="50%">
<img src="../images/accumB-flip.png" /><br />

</td>
</tr>
</table>
<p>It is like <code>accumE</code> because it accumulates the composition of the functions inside the various occurrences of the event, and it is like <code>stepper</code> because the change isn’t observable until the next logical moment in time.</p>
Looking at <code>accumE</code> and <code>accumB</code> side by side might help:
<table>
<tr>
<td width="50%">
<img src="../images/accumE-flip.png" /><br />

</td>
<td width="50%">
<img src="../images/accumB-flip.png" /><br />

</td>
</tr>
</table>
<p>As a reminder, both <code>accumE</code> and <code>accumB</code> work nicely with <code>unions</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unions ::</span> [<span class="dt">Event</span> (a <span class="ot">-&gt;</span> a)] <span class="ot">-&gt;</span> <span class="dt">Event</span> (a <span class="ot">-&gt;</span> a)</code></pre></div>
<p>if we want to work with several events.</p>
<p>We can use this to accumulate all of the messages that we’ve seen:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- see Part3.Example3</span>
<span class="ot">handleMessage ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> m <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage) <span class="fu">=</span> <span class="kw">do</span>
  bMessages <span class="ot">&lt;-</span> accumB [] <span class="fu">$</span> 
    (\x xs <span class="ot">-&gt;</span> x <span class="fu">:</span> xs) <span class="fu">&lt;$&gt;</span> eMessage

  <span class="kw">let</span>
    format ls m <span class="fu">=</span> m <span class="fu">++</span> <span class="st">&quot; (previous messages: &quot;</span> <span class="fu">++</span> show ls <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    eOut <span class="fu">=</span> format <span class="fu">&lt;$&gt;</span> bMessages <span class="fu">&lt;@&gt;</span> eMessage
        
  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eOut</code></pre></div>
<h3 id="conditional-events-based-on-behaviors">Conditional events based on behaviors</h3>
<p>We can filter events using the value of a behavior at the time of the event using <code>whenE</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">whenE ::</span> <span class="dt">Behavior</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a </code></pre></div>
<p>This gives us one (slightly contrived) option for not printing anything special when the history is empty:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- see Part3.Example4</span>
<span class="ot">handleMessage ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> m <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage) <span class="fu">=</span> <span class="kw">do</span>
  bMessages <span class="ot">&lt;-</span> accumB [] <span class="fu">$</span>
    (\x xs <span class="ot">-&gt;</span> x <span class="fu">:</span> xs) <span class="fu">&lt;$&gt;</span> eMessage

  <span class="kw">let</span>
    format ls m <span class="fu">=</span> 
      m <span class="fu">++</span> 
      <span class="st">&quot; (previous messages: &quot;</span> <span class="fu">++</span> show ls <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    bHasMessages <span class="fu">=</span> (not <span class="fu">.</span> null) <span class="fu">&lt;$&gt;</span> bMessages
    eMessageWithHistory <span class="fu">=</span> whenE bHasMessages eMessage
    eOut <span class="fu">=</span> leftmost [
        format <span class="fu">&lt;$&gt;</span> bMessages <span class="fu">&lt;@&gt;</span> eMessageWithHistory
      , eMessage
      ]

  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eOut</code></pre></div>
<p>This is a nice example of using <code>leftmost</code> as like a <code>switch-case-default</code> statement. All of the inputs to <code>leftmost</code> are based on <code>eMessages</code>, but we have made one of them conditional. If the condition is met then we get the conditional event, otherwise we get the default event that is the last element in the list.</p>
<h3 id="trimming-the-history">Trimming the history</h3>
<p>If we just want to print the last 3 messages that we’ve seen we can do that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- see Part3.Example5</span>
<span class="ot">handleMessage ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> m <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage) <span class="fu">=</span> <span class="kw">do</span>
  bMessages <span class="ot">&lt;-</span> accumB [] <span class="fu">$</span>
    (\x xs <span class="ot">-&gt;</span> take <span class="dv">3</span> (x <span class="fu">:</span> xs)) <span class="fu">&lt;$&gt;</span> eMessage

  <span class="kw">let</span>
    format ls m <span class="fu">=</span> m <span class="fu">++</span> <span class="st">&quot; (previous messages: &quot;</span> <span class="fu">++</span> show ls <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    bHasMessages <span class="fu">=</span> (not <span class="fu">.</span> null) <span class="fu">&lt;$&gt;</span> bMessages
    eMessageWithHistory <span class="fu">=</span> whenE bHasMessages eMessage
    eOut <span class="fu">=</span> leftmost [
        format <span class="fu">&lt;$&gt;</span> bMessages <span class="fu">&lt;@&gt;</span> eMessageWithHistory
      , eMessage
      ]

  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eOut</code></pre></div>
<p>We do the trimming inside of the accumulation so that we don’t have a <code>Behavior</code> with collecting a list with unbounded length floating around in our system.</p>
<p>Hard-coding the <code>3</code> in there should be making us feel a little ill.</p>
<p>Maybe we want the number of messages to be configurable, or we want to tie it to a modifiable setting. We can get some future proofing for that by passing in the number of messages that we want as a behavior.</p>
<p>Doing this is a common FRP idiom.</p>
<p>This is how it looks:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- see Part3.Example6</span>
<span class="kw">data</span> <span class="dt">MessageInput</span> <span class="fu">=</span> <span class="dt">MessageInput</span> {
<span class="ot">    mieRead  ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  ,<span class="ot"> mibLimit ::</span> <span class="dt">Behavior</span> <span class="dt">Int</span>
  }

<span class="ot">handleMessage ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> m <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage bLimit) <span class="fu">=</span> <span class="kw">do</span>
  bMessages <span class="ot">&lt;-</span> accumB [] <span class="fu">$</span>
    (\n x xs <span class="ot">-&gt;</span> take n (x <span class="fu">:</span> xs)) <span class="fu">&lt;$&gt;</span> bLimit <span class="fu">&lt;@&gt;</span> eMessage

  <span class="kw">let</span>
    format ls m <span class="fu">=</span> m <span class="fu">++</span> <span class="st">&quot; (previous messages: &quot;</span> <span class="fu">++</span> show ls <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    bHasMessages <span class="fu">=</span> (not <span class="fu">.</span> null) <span class="fu">&lt;$&gt;</span> bMessages
    eMessageWithHistory <span class="fu">=</span> whenE bHasMessages eMessage
    eOut <span class="fu">=</span> leftmost [
        format <span class="fu">&lt;$&gt;</span> bMessages <span class="fu">&lt;@&gt;</span> eMessageWithHistory
      , eMessage
      ]

  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eOut</code></pre></div>
<p>If we want to hard-code a limit of 3 for the time being, we can set it up with <code>pure 3</code>. Later on, we might add some code for admins to alter the limit - if that contributes to a behavior, and if our various components take their parameters as behaviors, then all we need to do is wire it up to our components.</p>
<h3 id="a-component-for-the-history-limit">A component for the history limit</h3>
<p>In order to modify the limit as we go, we need to introduce a few more pieces.</p>
<p>Let’s assume that the limit on the history starts at 1, and is modified by two events: one increments the limit, the other decrements the limit unless it is already at 0.</p>
<p>We can build a behavior for the limit using <code>accumB</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- see Part3.Example7</span>
<span class="kw">data</span> <span class="dt">LimitInput</span> <span class="fu">=</span> <span class="dt">LimitInput</span> {
<span class="ot">    lieLimitUp   ::</span> <span class="dt">Event</span> ()
  ,<span class="ot"> lieLimitDown ::</span> <span class="dt">Event</span> ()
  }

<span class="kw">data</span> <span class="dt">LimitOutput</span> <span class="fu">=</span> <span class="dt">LimitOutput</span> {
<span class="ot">    lobLimit ::</span> <span class="dt">Behavior</span> <span class="dt">Int</span>
  }

<span class="ot">handleLimit ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">LimitInput</span> <span class="ot">-&gt;</span> m <span class="dt">LimitOutput</span>
handleLimit (<span class="dt">LimitInput</span> eUp eDown) <span class="fu">=</span> <span class="kw">do</span>
  bLimit <span class="ot">&lt;-</span> accumB <span class="dv">1</span> <span class="fu">.</span> unions <span class="fu">$</span> [
      succ <span class="fu">&lt;$</span> eUp
    , (max <span class="dv">0</span> <span class="fu">.</span> pred) <span class="fu">&lt;$</span> eDown
    ]
  return <span class="fu">$</span> <span class="dt">LimitOutput</span> bLimit</code></pre></div>
<p>If we wanted to be a little fancier for no real good reason, we could use recursive values via the <code>RecursiveDo</code> language extension:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecursiveDo #-}</span>
<span class="ot">handleLimit ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">LimitInput</span> <span class="ot">-&gt;</span> m <span class="dt">LimitOutput</span>
handleLimit (<span class="dt">LimitInput</span> eUp eDown) <span class="fu">=</span> mdo
  <span class="kw">let</span>
    eDownNonNegative <span class="fu">=</span> whenE ((<span class="fu">&gt;</span> <span class="dv">0</span>) <span class="fu">&lt;$&gt;</span> bLimit) eDown
  bLimit <span class="ot">&lt;-</span> accumB <span class="dv">1</span> <span class="fu">.</span> unions <span class="fu">$</span> [
      succ <span class="fu">&lt;$</span> eUp
    , pred <span class="fu">&lt;$</span> eDownNonNegative
    ]
  return <span class="fu">$</span> <span class="dt">LimitOutput</span> bLimit</code></pre></div>
<p>The behavior gives us something like a step function, but we might end up wanting an event that triggers when the behavior changes.</p>
<p>We can do that with <code>accumE</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">eLimit <span class="ot">&lt;-</span> accumE <span class="dv">1</span> <span class="fu">.</span> unions <span class="fu">$</span> [
    succ <span class="fu">&lt;$</span> eUp
  , (max <span class="dv">0</span> <span class="fu">.</span> pred) <span class="fu">&lt;$</span> eDown
  ]</code></pre></div>
<p>If we wind up needing both, we can efficiently combine the two of these by using <code>mapAccum</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mapAccum ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> acc <span class="ot">-&gt;</span> <span class="dt">Event</span> (acc <span class="ot">-&gt;</span> (x, acc)) <span class="ot">-&gt;</span> m (<span class="dt">Event</span> x, <span class="dt">Behavior</span> acc) </code></pre></div>
<p>This version uses <code>mapAccum</code> to do this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LimitInput</span> <span class="fu">=</span> <span class="dt">LimitInput</span> {
<span class="ot">    lieLimitUp ::</span> <span class="dt">Event</span> ()
  ,<span class="ot"> lieLimitDown ::</span> <span class="dt">Event</span> ()
  }

<span class="kw">data</span> <span class="dt">LimitOutput</span> <span class="fu">=</span> <span class="dt">LimitOutput</span> {
<span class="ot">    loeLimit ::</span> <span class="dt">Event</span> <span class="dt">Int</span>
  ,<span class="ot"> lobLimit ::</span> <span class="dt">Behavior</span> <span class="dt">Int</span>
  }

<span class="ot">handleLimit ::</span> <span class="dt">MonadMoment</span> m <span class="ot">=&gt;</span> <span class="dt">LimitInput</span> <span class="ot">-&gt;</span> m <span class="dt">LimitOutput</span>
handleLimit (<span class="dt">LimitInput</span> eUp eDown) <span class="fu">=</span> <span class="kw">do</span>
  (eLimit, bLimit) <span class="ot">&lt;-</span> mapAccum <span class="dv">1</span> <span class="fu">.</span> fmap (\f x <span class="ot">-&gt;</span> (f x, f x)) <span class="fu">.</span> unions <span class="fu">$</span> [
      succ <span class="fu">&lt;$</span> eUp
    , (max <span class="dv">0</span> <span class="fu">.</span> pred) <span class="fu">&lt;$</span> eDown
    ]
  return <span class="fu">$</span> <span class="dt">LimitOutput</span> eLimit bLimit</code></pre></div>
<p>Having both a behavior and an event that triggers when the behavior changes can be handy, so you’ll see this idiom appear in a few of the <code>reactive-banana</code> examples floating around on the internet.</p>
<p>It’s useful in this example as well.</p>
<p>Let’s have a look at a sample interaction with our program:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> a
a
<span class="fu">&gt;</span> b
b (previous messages<span class="fu">:</span> [<span class="st">&quot;a&quot;</span>])
<span class="fu">&gt;</span> c
c (previous messages<span class="fu">:</span> [<span class="st">&quot;b&quot;</span>])
<span class="fu">&gt;</span> <span class="fu">/</span>limitup
<span class="fu">&gt;</span> d
d (previous messages<span class="fu">:</span> [<span class="st">&quot;c&quot;</span>])         <span class="co">-- (1)</span>
<span class="fu">&gt;</span> e
e (previous messages<span class="fu">:</span> [<span class="st">&quot;d&quot;</span>,<span class="st">&quot;c&quot;</span>])
<span class="fu">&gt;</span> f
f (previous messages<span class="fu">:</span> [<span class="st">&quot;e&quot;</span>,<span class="st">&quot;d&quot;</span>])
<span class="fu">&gt;</span> <span class="fu">/</span>limitup
<span class="fu">&gt;</span> g
g (previous messages<span class="fu">:</span> [<span class="st">&quot;f&quot;</span>,<span class="st">&quot;e&quot;</span>])
<span class="fu">&gt;</span> h
h (previous messages<span class="fu">:</span> [<span class="st">&quot;g&quot;</span>,<span class="st">&quot;f&quot;</span>,<span class="st">&quot;e&quot;</span>])
<span class="fu">&gt;</span> i
i (previous messages<span class="fu">:</span> [<span class="st">&quot;h&quot;</span>,<span class="st">&quot;g&quot;</span>,<span class="st">&quot;f&quot;</span>])
<span class="fu">&gt;</span> <span class="fu">/</span>limitdown
<span class="fu">&gt;</span> j
j (previous messages<span class="fu">:</span> [<span class="st">&quot;i&quot;</span>,<span class="st">&quot;h&quot;</span>,<span class="st">&quot;g&quot;</span>]) <span class="co">-- (2)</span>
<span class="fu">&gt;</span> k
k (previous messages<span class="fu">:</span> [<span class="st">&quot;j&quot;</span>,<span class="st">&quot;i&quot;</span>])
<span class="fu">&gt;</span> l
l (previous messages<span class="fu">:</span> [<span class="st">&quot;k&quot;</span>,<span class="st">&quot;j&quot;</span>])</code></pre></div>
<p>Notes:</p>
<ol style="list-style-type: decimal">
<li>This is fine - we have raised the limit, but have fewer messages in history than the limit.</li>
<li>This is less good - we have lowered the limit, another message has come through, and we’re still storing more than the current limit.</li>
</ol>
<p>It’s not the end of the world, but we’d like to trim that history a little sooner.</p>
<p>In order to do that we’ll use the version of the ‘limit’ component that produces both an event and a behavior, and we’ll update our ‘message’ component to make use of it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MessageInput</span> <span class="fu">=</span> <span class="dt">MessageInput</span> {
<span class="ot">    mieMessage ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  ,<span class="ot"> mieLimit   ::</span> <span class="dt">Event</span> <span class="dt">Int</span>
  ,<span class="ot"> mibLimit   ::</span> <span class="dt">Behavior</span> <span class="dt">Int</span>
  }

<span class="kw">data</span> <span class="dt">MessageOutput</span> <span class="fu">=</span> <span class="dt">MessageOutput</span> {
<span class="ot">    moeWrite ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  }

<span class="ot">handleMessage ::</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage eLimit bLimit) <span class="fu">=</span> <span class="kw">do</span>
  bMessages <span class="ot">&lt;-</span> accumB [] <span class="fu">$</span> unions [
      (\n x xs <span class="ot">-&gt;</span> take n (x <span class="fu">:</span> xs)) <span class="fu">&lt;$&gt;</span> bLimit <span class="fu">&lt;@&gt;</span> eMessage
    , take <span class="fu">&lt;$&gt;</span> eLimit                                              <span class="co">-- (1)</span>
    ]

  <span class="kw">let</span>
    format ls m <span class="fu">=</span> m <span class="fu">++</span> <span class="st">&quot; (previous messages: &quot;</span> <span class="fu">++</span> show ls <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    bHasMessages <span class="fu">=</span> (not <span class="fu">.</span> null) <span class="fu">&lt;$&gt;</span> bMessages
    eMessageWithHistory <span class="fu">=</span> whenE bHasMessages eMessage
    eOut <span class="fu">=</span> leftmost [
        format <span class="fu">&lt;$&gt;</span> bMessages <span class="fu">&lt;@&gt;</span> eMessageWithHistory
      , eMessage
      ]

  return <span class="fu">$</span> <span class="dt">MessageOutput</span> eOut</code></pre></div>
<p>Notes:</p>
<ol style="list-style-type: decimal">
<li>We trim the messages when we get an event indicating that the limit has changed.</li>
</ol>
<p>Now that same interaction with the new program looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> a
a
<span class="fu">&gt;</span> b
b (previous messages<span class="fu">:</span> [<span class="st">&quot;a&quot;</span>])
<span class="fu">&gt;</span> c
c (previous messages<span class="fu">:</span> [<span class="st">&quot;b&quot;</span>])
<span class="fu">&gt;</span> <span class="fu">/</span>limitup
<span class="fu">&gt;</span> d
d (previous messages<span class="fu">:</span> [<span class="st">&quot;c&quot;</span>])
<span class="fu">&gt;</span> e
e (previous messages<span class="fu">:</span> [<span class="st">&quot;d&quot;</span>,<span class="st">&quot;c&quot;</span>])
<span class="fu">&gt;</span> f
f (previous messages<span class="fu">:</span> [<span class="st">&quot;e&quot;</span>,<span class="st">&quot;d&quot;</span>])
<span class="fu">&gt;</span> <span class="fu">/</span>limitup
<span class="fu">&gt;</span> g
g (previous messages<span class="fu">:</span> [<span class="st">&quot;f&quot;</span>,<span class="st">&quot;e&quot;</span>])
<span class="fu">&gt;</span> h
h (previous messages<span class="fu">:</span> [<span class="st">&quot;g&quot;</span>,<span class="st">&quot;f&quot;</span>,<span class="st">&quot;e&quot;</span>])
<span class="fu">&gt;</span> i
i (previous messages<span class="fu">:</span> [<span class="st">&quot;h&quot;</span>,<span class="st">&quot;g&quot;</span>,<span class="st">&quot;f&quot;</span>])
<span class="fu">&gt;</span> <span class="fu">/</span>limitdown
<span class="fu">&gt;</span> j
j (previous messages<span class="fu">:</span> [<span class="st">&quot;i&quot;</span>,<span class="st">&quot;h&quot;</span>])     <span class="co">-- (1)</span>
<span class="fu">&gt;</span> k
k (previous messages<span class="fu">:</span> [<span class="st">&quot;j&quot;</span>,<span class="st">&quot;i&quot;</span>])
<span class="fu">&gt;</span> l
l (previous messages<span class="fu">:</span> [<span class="st">&quot;k&quot;</span>,<span class="st">&quot;j&quot;</span>])</code></pre></div>
<p>Notes</p>
<ol style="list-style-type: decimal">
<li>The message history has been trimmed in a timely fashion.</li>
</ol>
<h2 id="testing-with-behaviors">Testing with behaviors</h2>
<p>This will be filled in once I have dealt with some rough edges.</p>
<!-- 
This next section is a bit gory, but is here to demonstrate that you can test event networks which have behaviors in their inputs and outputs if you're willing to get your hands dirty.

If that doesn't sound like your cup of tea, feel free to [skip ahead](./components.html).

In order to test code that has behaviors as inputs or outputs, we need to modify our testing code.

I'm not advocating actually using this, since it's much messier than it needs to be.
I just wanted something to give people a starting point, and to show that it can be done.

We add a data type to carry information about both the behaviors and the events that are inputs to our event network: 
```haskell
data Command b e = Command {
    _cmdB :: b
  , _cmdE :: e
  } deriving (Eq, Ord, Show)

mkLenses ''Command
```
and change the `Fannable` class to use it:
```haskell
class Fannable b e where
  type Fanned b e
  fanInput :: Testable m => Event (Command b e) -> m (Fanned b e)
```

The idea here is that we'll use the input events and the values in `cmdB` to reconstitute the behaviors using `stepper`.

For the outputs we make a similar change.
We carry the behaviors and possibly multiple simultaneous events in our data type:
```haskell
data Result b e = Result {
    _resB :: b
  , _resE :: [e]
  } deriving (Eq, Ord, Show)

mkLenses ''Result
```
and the the `Mergable` class uses that and picks up an extra argument:
```haskell
class Mergable b e where
  type ToMerge b e
  mergeOutput :: Event () -> ToMerge b e -> Event (Result b e)
```

We will use the input event to our event network for this extra argument, which will provide an event for every observable point of time in our event network.
We use this to sample the output behaviors.

We see this at work in the version of `testNetwork`:
```haskell
testNetwork :: ( 
            Testable m
          , Fannable ib ie
          , Mergable ob oe
          ) => (Fanned ib ie -> m (ToMerge ob oe)) 
            -> [Maybe (Command ib ie)] 
            -> IO [Maybe (Result ob oe)]
testNetwork fn =
  interpretEvents $ \i -> do
    fi <- fanInput i
    o <- fn fi
    return $ mergeOutput (() <$ i) o
```

We'll also add some helper functions for `Fannable`:
```haskell
fanE :: (Testable m, Fannable b e) 
     => Prism' e a                -- ^ a prism used to extract this particular Event
     -> Event (Command b e)       -- ^ the combined Event we're extracting this Event from
     -> m (Event a)               -- ^ the particular Event we are after

fanB :: (Testable m, Fannable b e) 
     => a                         -- ^ the initial value for the Behavior we're extracting
     -> Lens' b a                 -- ^ a lens to used to extract this particular Behavior 
                                  --   from our combined Behavior type b
     -> Event (Command b e)       -- ^ the combined Event we're extracting this Behavior from
     -> m (Behavior a)            -- ^ the reconstituted Behavior
```
and for `Mergable`:
```haskell
-- We're grabbing the values of multiple Events, without knowing if they're happening simultaneously.
-- We want to track this - which is why we record a list of event values per time slice.
-- On top of all of that, we're also sampling the Behaviors at every point in time, so there's collisions 
-- happening there as well.
-- 
-- We use this function with `unionWith` to sort that out.
combineResult :: Result b e -> Result b e -> Result b e
combineResult (Result b1 e1) (Result b2 e2) =
  Result 
    -- When this collision happens, it'll happen at the same point in time, so the two sampled values for the 
    -- Behaviors should be the same, so we can just chose either one.
    b1 
    -- When we sample a Behavior, we use an empty list for the Event portion of the Result
    (e1 ++ e2)

mergeE :: Mergable b e 
       => Behavior b 
       -> Prism' e a 
       -> Event a 
       -> Event (Result b e)

mergeB :: Mergable b e 
       => Behavior b 
       -> Event () 
       -> Event (Result b e)
```

Let's take a look at them in action.

### Testing `handleLimit`

TODO mention that we're working with the version that outputs both events and behaviors

```haskell
data LimitInputE =
    LLimitUp
  | LLimitDown
  deriving (Eq, Ord, Show)

makePrisms ''LimitInputE

instance Fannable () LimitInputE where
  type Fanned () LimitInputE = LimitInput
  fanInput eIn =
    LimitInput <$>
      fanE _LLimitUp eIn <*>
      fanE _LLimitDown eIn
```

```haskell
instance Mergable Int Int where
  type ToMerge Int Int = LimitOutput
  mergeOutput eSample (LimitOutput eLimit bLimit) =
    unionWith combineResult
      (mergeE bLimit id eLimit)
      (mergeB bLimit eSample)
```

```haskell
testLimit ::    [Maybe (Command () LimitInputE)] 
          -> IO [Maybe (Result Int Int)]
testLimit = 
  testNetwork handleLimit
```

```haskell
> xs <- testLimit [
    Just (Command () LLimitUp)
  , Just (Command () LLimitUp)
  , Just (Command () LLimitDown)
  ]
> xs
[ Just (Result {_resB = 1, _resE = [2]})
, Just (Result {_resB = 2, _resE = [3]})
, Just (Result {_resB = 3, _resE = [2]})
]
```

### Testing `handleMessage`

TODO talk about how we test handleMessage, se we can see what happens with behaviors in the inputs

```haskell
data MessageInputE =
    MMessage String
  | MLimit Int
  deriving (Eq, Ord, Show)

makePrisms ''MessageInputE

instance Fannable Int String where
  type Fanned Int MessageInputE = MessageInput
  fanInput eIn =
    MessageInput <$>
      fanE _MMessage eIn <*>
      fanB 0 id eIn
```

```haskell
instance Mergable () String where
  type ToMerge () String = MessageOutput
  mergeOutput _ (MessageOutput eWrite) =
    mergeE (pure ()) _MWrite eWrite
```

```haskell
testMessage ::    [Maybe (Command Int String)] 
            -> IO [Maybe (Result () String)]
testMessage = 
  testNetwork handleMessage
```
-->
<h2 id="next-up">Next up</h2>
<p>Now that we have some idea of what we can do with behaviors, we’re going to start putting together some of the pieces we’ll end up using in our chat server.</p>
<p>We’ll begin by putting together all of the pieces that we can inside of a command line application, in order to introduce one or two more tricks.</p>
<p><a href="./components.html">Onwards!</a></p>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on October  1, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
