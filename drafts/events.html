<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Events</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../css/custom.css">
        <link rel="stylesheet" href="../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - A Series on Behaviors and Events" href="../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - A series on behaviours and events" href="../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../">A Series on Behaviors and Events</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../drafts/events.html">Events</a></h3>
    </div>
    <div class="panel-body">
        <p>There are two main data types in FRP - <code>Event</code>s and <code>Behavior</code>s - and we combine them together to build an FRP event network which describes how our program is going to respond to various events over time.</p>
<h1 id="events">Events</h1>
<p>An <code>Event</code> is something that happens at a particular point of time - like a button press, or a key press, or the receipt of a HTTP request - and a <code>Behavior</code> is something that has values at all points of time.</p>
<p>For our purposes, this is a <em>logical</em> view of time, where are logical clock ticks every time an event is fired from <em>outside</em> of our FRP event network.</p>
<p>Let’s take a look at <code>Event</code> from <code>reactive-banana</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Event</span> a</code></pre></div>
<p>which has a <code>Functor</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Event</span> <span class="kw">where</span> <span class="fu">...</span></code></pre></div>
<h2 id="simultaneous-events">Simultaneous <code>Event</code>s</h2>
<p>The <code>Functor</code> instance provides a good example of how we can end up with multiple events happening at the same time originating from the <em>inside</em> of our event network.</p>
<p>The simplest demonstration of this is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">doubler ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span>
doubler eNumber <span class="fu">=</span>
  <span class="kw">let</span>
    eOtherNumber <span class="fu">=</span> (<span class="fu">*</span> <span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> eNumber
  <span class="kw">in</span>
    eOtherNumber</code></pre></div>
<p>where <code>eNumber</code> and <code>eOtherNumber</code> are active at the same logical points in time.</p>
<p>(I’m using the <code>let</code> above to give things a name that I can refer to easily).</p>
<p>We could also use</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterE ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</code></pre></div>
<p>to do</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evener ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span>
evener eNumber <span class="fu">=</span>
  <span class="kw">let</span>
    eEven <span class="fu">=</span> filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">0</span>) eNumber
  <span class="kw">in</span>
    eEven</code></pre></div>
<p>and <code>eEven</code> will be active at the logical points in time when <code>eNumber</code> is both active and has an even value.</p>
<p>If you’re dealing with a function in <code>reactive-banana</code> that has a <em>pure</em> <code>Event</code> as an output, then the output <code>Event</code> will only ever be active at the same logical points of time as the input <code>Event</code>s. The output <code>Event</code> maybe be active less often - as was the case with <code>filterE</code> - but it will always be active at the same time as one or more of the input events.</p>
<p>This becomes relevant when we start combining <code>Event</code>s.</p>
<p>If we never had simultaneous events, we could use something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">union ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</code></pre></div>
<p>which would activate the output whenever either of the inputs were active.</p>
<p>We have to deal with the possibility of events occurring at the same time, and so <code>reactive-banana</code> provides:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unionWith ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</code></pre></div>
<p>If the one of the input events is active and the other event is not, then the output is activated with the value of the active input. If both events are active at the same time, then we combine the output is activated with the value that results from running the combining function on the two active values.</p>
<p>Now we can use that to get some important work done:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">importantWork ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">String</span>
importantWork eCount <span class="fu">=</span>
  <span class="kw">let</span>
    eFizz <span class="fu">=</span> 
      fmap (\_ <span class="ot">-&gt;</span> <span class="st">&quot;Fizz&quot;</span>) <span class="fu">.</span> 
      filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">$</span>
      eCount
    eBuzz <span class="fu">=</span> 
      fmap (\_ <span class="ot">-&gt;</span> <span class="st">&quot;Buzz&quot;</span>) <span class="fu">.</span> 
      filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">5</span> <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">$</span>
      eCount
    eFizzBuzz <span class="fu">=</span> 
      unionWith (\_ _ <span class="ot">-&gt;</span> <span class="st">&quot;FizzBuzz&quot;</span>) 
      eFizz 
      eBuzz
  <span class="kw">in</span>
    eFizzBuzz</code></pre></div>
<p>although we’d probably refactor that a little.</p>
<p>We’ll remove some duplication, and we’ll switch to using <code>&lt;$</code> since it’s pretty usual to use <code>&lt;$&gt;</code> and <code>&lt;$</code> in FRP code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">multiple ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span>
multiple m <span class="fu">=</span> 
  filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> m <span class="fu">==</span> <span class="dv">0</span>)

<span class="ot">importantWork ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">String</span>
importantWork eCount <span class="fu">=</span>
  <span class="kw">let</span>
    eFizz <span class="fu">=</span> 
      <span class="st">&quot;Fizz&quot;</span> <span class="fu">&lt;$</span> multiple <span class="dv">3</span> eCount
    eBuzz <span class="fu">=</span> 
      <span class="st">&quot;Buzz&quot;</span> <span class="fu">&lt;$</span> multiple <span class="dv">5</span> eCount
    eFizzBuzz <span class="fu">=</span> 
      unionWith (\_ _ <span class="ot">-&gt;</span> <span class="st">&quot;FizzBuzz&quot;</span>) 
      eFizz 
      eBuzz
  <span class="kw">in</span>
    eFizzBuzz</code></pre></div>
<p>That’s right. I totally went there.</p>
<h2 id="connecting-the-event-network">Connecting the event network</h2>
<p>Now that we’ve looking a little at the inside of the event network, it is time to take a look at how these things look from the outside.</p>
<p>We’re going to be doing this by breaking ground on our first FRP application, which will be a command line application that echoes input.</p>
<p>It’ll get more impressive soon, I promise.</p>
<p>When building an FRP app there are usually two pieces - or at least two kinds of pieces - that are involved. There is the event network, which is where the FRP happens, and the event loop, which feeds events into the network from the outside.</p>
<p>There are several functions we can use to bridge that gap, but the one we’ll be most interested in is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newAddHandler ::</span> <span class="dt">IO</span> (<span class="dt">AddHandler</span> a, a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) </code></pre></div>
<p>We can unpack that into a data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">EventSource</span> a <span class="fu">=</span> <span class="dt">EventSource</span> {
<span class="ot">    addHandler ::</span> <span class="dt">AddHandler</span> a
  ,<span class="ot"> fire       ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
  }

<span class="ot">mkEventSource ::</span> <span class="dt">IO</span> (<span class="dt">EventSource</span> a)
mkEventSource <span class="fu">=</span>
  uncurry <span class="dt">EventSource</span> <span class="fu">&lt;$&gt;</span> newAddHandler</code></pre></div>
<p>where <code>addHandler</code> is used to subscribe to event updates from inside the event network, and <code>fire</code> is used to initiate events from the event loop.</p>
<p>For the event loop of our command line, input echoing application, we just need to repeatedly read lines and fire the event:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eventLoop ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
eventLoop i <span class="fu">=</span>
  forever <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> getLine
    fire i x</code></pre></div>
<p>Every event that we fire from the outside occurs at a distinct moment in logical time. In the documentation for <code>sodium</code> these are referred to as transactions - which can be a helpful way of thinking of them - and the transactions have their own context.</p>
<p>In <code>reactive-banana</code> this context is provided by the <code>Moment</code> and <code>MomentIO</code> monads. If you see these in the signature of a function, it means that you’re dealing with something that is outside of the current moment in logical time.</p>
<p>For the event network, we use two functions from <code>reactive-banana</code> that operate in the <code>MomentIO</code> monad.</p>
<p>We register our event sources using:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromAddHandler ::</span> <span class="dt">AddHandler</span> a <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> (<span class="dt">Event</span> a) </code></pre></div>
<p>and we cause <code>IO</code> to happen in response to events using:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reactimate ::</span> <span class="dt">Event</span> (<span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> () </code></pre></div>
<p>The use of <code>MomentIO</code> in here makes some kind of sense. We will get the events after we register for them, and the <code>IO</code> output will occur after the event that triggers it. I found that my intuition for the <code>Moment</code> monads really took a step up once I started using them inside of the event networks. We’ll get to that soon.</p>
<p>With these two functions in our toolbox, we can describe our first event network:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription i <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- register for events when we have read a line</span>
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> i

  <span class="kw">let</span>
    <span class="co">-- we want to write whatever we have read</span>
    eWrite <span class="fu">=</span> eRead

  <span class="co">-- write the line </span>
  reactimate <span class="fu">$</span> putStrLn <span class="fu">&lt;$&gt;</span> eWrite</code></pre></div>
<p>Finally we need to glue everything together:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">go ::</span> <span class="dt">IO</span> ()
go <span class="fu">=</span> <span class="kw">do</span>
  input <span class="ot">&lt;-</span> mkEventSource
  network <span class="ot">&lt;-</span> compile <span class="fu">$</span> networkDescription input
  actuate network
  eventLoop input</code></pre></div>
<p>We use <code>compile</code> to create a <code>NetworkDescription</code> and <code>actuate</code> to get it kicking over. Most of our programs are going to do pretty similar things with respect to gluing things together, so it’s unlikely that we’ll delve too deeply into that last piece of code.</p>
<p>So far it’s not a very impressive event network, but it makes for a nice starting point.</p>
<h2 id="improvements-to-the-echo-program">Improvements to the echo program</h2>
<p>We can improve this program quite a bit.</p>
<h3 id="adding-the-ability-to-quit">Adding the ability to quit</h3>
<p>Let us start by adding the ability to quit the program when the user types “/quit”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess) 

<span class="ot">networkDescription ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription i <span class="fu">=</span> <span class="kw">do</span>
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> i

  <span class="kw">let</span>
    eMessage <span class="fu">=</span> filterE (<span class="fu">/=</span> <span class="st">&quot;/quit&quot;</span>) eRead
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eRead

  reactimate <span class="fu">$</span> putStrLn <span class="fu">&lt;$&gt;</span> eMessage
  reactimate <span class="fu">$</span> exitSuccess <span class="fu">&lt;$</span> eQuit</code></pre></div>
<p>So far, so good.</p>
<h3 id="printing-a-message-on-exit">Printing a message on exit</h3>
<p>Now let’s say goodbye to the user before we go.</p>
<p>We’re going to introduce some helper functions here, to help deal with multiple non-simultaneous events. We know they’re non-simultaneous because they’re all going to be derived from <code>eRead</code>.</p>
<p>First we have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">orElse ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a
orElse <span class="fu">=</span> unionWith const</code></pre></div>
<p>which picks the first of two events if they are activated simultaneously.</p>
<p>We can extend that to a list of events with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">leftmost ::</span> [<span class="dt">Event</span> a] <span class="ot">-&gt;</span> <span class="dt">Event</span> a
leftmost <span class="fu">=</span> foldl orElse never</code></pre></div>
<p>which I tend to use more than <code>orElse</code>, since I tend to refactor FRP programs and it’s quicker to add or remove things from a list than it is to chain together a heap of events using <code>orElse</code>.</p>
<p>We’re using <code>never</code> in there, which is from <code>reactive-banana</code>, and is an event that never fires. It’s handy for things like the <code>leftmost</code>.</p>
<p>The change to print a message on exit is pretty small:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription i <span class="fu">=</span> <span class="kw">do</span>
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> i

  <span class="kw">let</span>
    eMessage <span class="fu">=</span> filterE (<span class="fu">/=</span> <span class="st">&quot;/quit&quot;</span>) eRead
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eRead

  reactimate <span class="fu">$</span> fmap putStrLn <span class="fu">.</span> leftmost <span class="fu">$</span> [
      eMessage
    , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
    ]
  reactimate <span class="fu">$</span> exitSuccess <span class="fu">&lt;$</span> eQuit</code></pre></div>
<h3 id="printing-a-greeting">Printing a greeting</h3>
<p>We’ve said goodbye, so we should probably also say hello.</p>
<p>In order to do that, our event network is going to need to know when the program has started.</p>
<p>We’ll add a new <code>EventSource</code> for that, and we’ll collect the <code>EventSource</code>s together into a data structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">InputSources</span> <span class="fu">=</span> <span class="dt">InputSources</span> {
<span class="ot">    isOpen ::</span> <span class="dt">EventSource</span> ()
  ,<span class="ot"> isRead ::</span> <span class="dt">EventSource</span> <span class="dt">String</span>
  }</code></pre></div>
<p>It’s pretty easy to build one of these:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkInputSources ::</span> <span class="dt">IO</span> <span class="dt">InputSources</span>
mkInputSources <span class="fu">=</span>
  <span class="dt">InputSources</span> <span class="fu">&lt;$&gt;</span> mkEventSource <span class="fu">&lt;*&gt;</span> mkEventSource</code></pre></div>
<p>From the outside of the event network, we need to fire the open event from the event loop:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eventLoop ::</span> <span class="dt">InputSources</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
eventLoop (<span class="dt">InputSources</span> o r) <span class="fu">=</span> <span class="kw">do</span>
  fire o ()
  forever <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> getLine
    fire r x</code></pre></div>
<p>From the inside of the event network, we need to register for open events and use those events to print a greeting:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">InputSources</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription (<span class="dt">InputSources</span> o r) <span class="fu">=</span> <span class="kw">do</span>
  eOpen <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> o
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> r

  <span class="kw">let</span>
    eMessage <span class="fu">=</span> filterE (<span class="fu">/=</span> <span class="st">&quot;/quit&quot;</span>) eRead
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eRead

  reactimate <span class="fu">$</span> fmap putStrLn <span class="fu">.</span> leftmost <span class="fu">$</span> [
      <span class="st">&quot;Hi&quot;</span> <span class="fu">&lt;$</span> eOpen
    , eMessage
    , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
    ]
  reactimate <span class="fu">$</span> exitSuccess <span class="fu">&lt;$</span> eQuit</code></pre></div>
<p>Then we just need to hook everything up:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">go ::</span> <span class="dt">IO</span> ()
go <span class="fu">=</span> <span class="kw">do</span>
  input <span class="ot">&lt;-</span> mkInputSources
  network <span class="ot">&lt;-</span> compile <span class="fu">$</span> networkDescription input
  actuate network
  eventLoop input</code></pre></div>
<h3 id="adding-a-help-command">Adding a help command</h3>
<p>Next we’re going to add a help command:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">InputSources</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription (<span class="dt">InputSources</span> o r) <span class="fu">=</span> <span class="kw">do</span>
  eOpen <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> o
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> r

  <span class="kw">let</span>
    eMessage <span class="fu">=</span> filterE (<span class="fu">/=</span> <span class="st">&quot;/&quot;</span> <span class="fu">.</span> take <span class="dv">1</span>) eRead
    eHelp    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/help&quot;</span>) eRead
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eRead

  reactimate <span class="fu">$</span> fmap putStrLn <span class="fu">.</span> leftmost <span class="fu">$</span> [
      <span class="st">&quot;Hi (type /help for instructions)&quot;</span> <span class="fu">&lt;$</span> eOpen
    , eMessage
    , <span class="st">&quot;/help displays this message\n/quit exits the program&quot;</span> <span class="fu">&lt;$</span> eHelp
    , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
    ]
  reactimate <span class="fu">$</span> exitSuccess <span class="fu">&lt;$</span> eQuit</code></pre></div>
<p>This involves altering <code>eMessage</code> so that it stays out of the way of the other commands.</p>
<h3 id="detecting-the-use-of-unknown-commands">Detecting the use of unknown commands</h3>
<p>To top it all off, we’re going to detect the use of unknown commands.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">InputSources</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription (<span class="dt">InputSources</span> o r) <span class="fu">=</span> <span class="kw">do</span>
  eOpen <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> o
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> r

  <span class="kw">let</span>
    eMessage <span class="fu">=</span> filterE (<span class="fu">/=</span> <span class="st">&quot;/&quot;</span> <span class="fu">.</span> take <span class="dv">1</span>) eRead
    eCommand <span class="fu">=</span> fmap (drop <span class="dv">1</span>) <span class="fu">.</span> filterE (<span class="fu">==</span> <span class="st">&quot;/&quot;</span> <span class="fu">.</span> take <span class="dv">1</span>) eRead
    eHelp    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;help&quot;</span>) eCommand
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;quit&quot;</span>) eCommand

    commands        <span class="fu">=</span> [<span class="st">&quot;help&quot;</span>, <span class="st">&quot;quit&quot;</span>]
    eUnknownCommand <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="ot">`notElem`</span> commands) eCommand

  reactimate <span class="fu">$</span> fmap putStrLn <span class="fu">.</span> leftmost <span class="fu">$</span> [
      <span class="st">&quot;Hi (type /help for instructions)&quot;</span> <span class="fu">&lt;$</span> eOpen
    , eMessage
    , <span class="st">&quot;/help displays this message\n/quit exits the program&quot;</span> <span class="fu">&lt;$</span> eHelp
    , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
    , (\x <span class="ot">-&gt;</span> <span class="st">&quot;Unknown command: &quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot; (type /help for instructions)&quot;</span>) <span class="fu">&lt;$&gt;</span> eUnknownCommand
    ]
  reactimate <span class="fu">$</span> exitSuccess <span class="fu">&lt;$</span> eQuit</code></pre></div>
<h2 id="next-up">Next up</h2>
<p>We’ve got our first little FRP application together, so we should be feeling pretty good.</p>
<p>Soon we’ll look at behaviors, which will let us write some more interesting programs.</p>
<p>Before that, we’re going to refactor what we have to make it more testable and to make the pieces more reusable.</p>
<p><a href="./refactoring.html">Onwards!</a></p>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on September  1, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
