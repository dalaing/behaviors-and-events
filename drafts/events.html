<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Events</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../css/custom.css">
        <link rel="stylesheet" href="../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - A Series on Behaviors and Events" href="../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - A series on behaviours and events" href="../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../">A Series on Behaviors and Events</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../drafts/events.html">Events</a></h3>
    </div>
    <div class="panel-body">
        <p>There are two main data types in FRP - <code>Event</code>s and <code>Behavior</code>s - and we combine them together to build an FRP event network which describes how our program is going to respond to various events over time.</p>
<h1 id="events">Events</h1>
<p>An <code>Event</code> is something that happens at a particular point of time - like a button press, or a key press, or the receipt of a HTTP request - and a <code>Behavior</code> is something that has values at all points of time.</p>
<p>For our purposes, this is a <em>logical</em> view of time, where are logical clock ticks every time an event is fired from <em>outside</em> of our FRP event network.</p>
<p>Let’s take a look at <code>Event</code> from <code>reactive-banana</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Event</span> a</code></pre></div>
<p>which has a <code>Functor</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Event</span> <span class="kw">where</span> <span class="fu">...</span></code></pre></div>
<h2 id="simultaneous-events">Simultaneous <code>Event</code>s</h2>
<p>The <code>Functor</code> instance provides a good example of how we can end up with multiple events happening at the same time originating from the <em>inside</em> of our event network.</p>
<p>The simplest demonstration of this is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">doubler ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span>
doubler eNumber <span class="fu">=</span>
  <span class="kw">let</span>
    eOtherNumber <span class="fu">=</span> (<span class="fu">*</span> <span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> eNumber
  <span class="kw">in</span>
    eOtherNumber</code></pre></div>
<p>where <code>eNumber</code> and <code>eOtherNumber</code> are active at the same logical points in time.</p>
<p>(I’m using the <code>let</code> above to give things a name that I can refer to easily).</p>
<p>We could also use</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterE ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</code></pre></div>
<p>to do</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evener ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span>
evener eNumber <span class="fu">=</span>
  <span class="kw">let</span>
    eEven <span class="fu">=</span> filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">0</span>) eNumber
  <span class="kw">in</span>
    eEven</code></pre></div>
<p>and <code>eEven</code> will be active at the logical points in time when <code>eNumber</code> is both active and has an even value.</p>
<p>If you’re dealing with a function in <code>reactive-banana</code> that has a <em>pure</em> <code>Event</code> as an output, then the output <code>Event</code> will only ever be active at the same logical points of time as the input <code>Event</code>s. The output <code>Event</code> maybe be active less often - as was the case with <code>filterE</code> - but it will always be active at the same time as one or more of the input events.</p>
<p>This becomes relevant when we start combining <code>Event</code>s.</p>
<p>If we never had simultaneous events, we could use something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">union ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</code></pre></div>
<p>which would activate the output whenever either of the inputs were active.</p>
<p>We have to deal with the possibility of events occurring at the same time, and so <code>reactive-banana</code> provides:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unionWith ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</code></pre></div>
<p>If the one of the input events is active and the other event is not, then the output is activated with the value of the active input. If both events are active at the same time, then we combine the output is activated with the value that results from running the combining function on the two active values.</p>
<p>Now we can use that to get some important work done:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">importantWork ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">String</span>
importantWork eCount <span class="fu">=</span>
  <span class="kw">let</span>
    eFizz <span class="fu">=</span> 
      fmap (\_ <span class="ot">-&gt;</span> <span class="st">&quot;Fizz&quot;</span>) <span class="fu">.</span> 
      filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">$</span>
      eCount
    eBuzz <span class="fu">=</span> 
      fmap (\_ <span class="ot">-&gt;</span> <span class="st">&quot;Buzz&quot;</span>) <span class="fu">.</span> 
      filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">5</span> <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">$</span>
      eCount
    eFizzBuzz <span class="fu">=</span> 
      unionWith (\_ _ <span class="ot">-&gt;</span> <span class="st">&quot;FizzBuzz&quot;</span>) 
      eFizz 
      eBuzz
  <span class="kw">in</span>
    eFizzBuzz</code></pre></div>
<p>although we’d probably refactor that a little.</p>
<p>We’ll remove some duplication, and we’ll switch to using <code>&lt;$</code> since it’s pretty usual to use <code>&lt;$&gt;</code> and <code>&lt;$</code> in FRP code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">multiple ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">Int</span>
multiple m <span class="fu">=</span> 
  filterE (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> m <span class="fu">==</span> <span class="dv">0</span>)

<span class="ot">importantWork ::</span> <span class="dt">Event</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">String</span>
importantWork eCount <span class="fu">=</span>
  <span class="kw">let</span>
    eFizz <span class="fu">=</span> 
      <span class="st">&quot;Fizz&quot;</span> <span class="fu">&lt;$</span> multiple <span class="dv">3</span> eCount
    eBuzz <span class="fu">=</span> 
      <span class="st">&quot;Buzz&quot;</span> <span class="fu">&lt;$</span> multiple <span class="dv">5</span> eCount
    eFizzBuzz <span class="fu">=</span> 
      unionWith (\_ _ <span class="ot">-&gt;</span> <span class="st">&quot;FizzBuzz&quot;</span>) 
      eFizz 
      eBuzz
  <span class="kw">in</span>
    eFizzBuzz</code></pre></div>
<p>That’s right. I totally went there.</p>
<h2 id="connecting-the-event-network">Connecting the event network</h2>
<p>Now that we’ve looking a little at the inside of the event network, it is time to take a look at how these things look from the outside.</p>
<p>We’re going to be doing this by breaking ground on our first FRP application, which will be a command line application that echoes input.</p>
<p>It’ll get more impressive soon, I promise.</p>
<p>When building an FRP app there are usually two pieces - or at least two kinds of pieces - that are involved. There is the event network, which is where the FRP happens, and the event loop, which feeds events into the network from the outside.</p>
<p>There are several functions we can use to bridge that gap, but the one we’ll be most interested in is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newAddHandler ::</span> <span class="dt">IO</span> (<span class="dt">AddHandler</span> a, a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) </code></pre></div>
<p>We can unpack that into a data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">EventSource</span> a <span class="fu">=</span> <span class="dt">EventSource</span> {
<span class="ot">    addHandler ::</span> <span class="dt">AddHandler</span> a
  ,<span class="ot"> fire       ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
  }

<span class="ot">mkEventSource ::</span> <span class="dt">IO</span> (<span class="dt">EventSource</span> a)
mkEventSource <span class="fu">=</span>
  uncurry <span class="dt">EventSource</span> <span class="fu">&lt;$&gt;</span> newAddHandler</code></pre></div>
<p>where <code>addHandler</code> is used to subscribe to event updates from inside the event network, and <code>fire</code> is used to initiate events from the event loop.</p>
<p>For the event loop of our command line, input echoing application, we just need to repeatedly read lines and fire the event:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eventLoop ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
eventLoop i <span class="fu">=</span>
  forever <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> getLine
    fire i x</code></pre></div>
<p>Every event that we fire from the outside occurs at a distinct moment in logical time. In the documentation for <code>sodium</code> these are referred to as transactions - which can be a helpful way of thinking of them - and the transactions have their own context.</p>
<p>In <code>reactive-banana</code> this context is provided by the <code>Moment</code> and <code>MomentIO</code> monads. If you see these in the signature of a function, it means that you’re dealing with something that is outside of the current moment in logical time.</p>
<p>For the event network, we use two functions from <code>reactive-banana</code> that operate in the <code>MomentIO</code> monad.</p>
<p>We register our event sources using:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromAddHandler ::</span> <span class="dt">AddHandler</span> a <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> (<span class="dt">Event</span> a) </code></pre></div>
<p>and we cause <code>IO</code> to happen in response to events using:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reactimate ::</span> <span class="dt">Event</span> (<span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> () </code></pre></div>
<p>The use of <code>MomentIO</code> in here makes some kind of sense. We will get the events after we register for them, and the <code>IO</code> output will occur after the event that triggers it. I found that my intuition for the <code>Moment</code> monads really took a step up once I started using them inside of the event networks. We’ll get to that soon.</p>
<p>With these two functions in our toolbox, we can describe our first event network:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription i <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- register for events when we have read a line</span>
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> i

  <span class="kw">let</span>
    <span class="co">-- we want to write whatever we have read</span>
    eWrite <span class="fu">=</span> eRead

  <span class="co">-- write the line </span>
  reactimate <span class="fu">$</span> putStrLn <span class="fu">&lt;$&gt;</span> eWrite</code></pre></div>
<p>Finally we need to glue everything together:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">go ::</span> <span class="dt">IO</span> ()
go <span class="fu">=</span> <span class="kw">do</span>
  input <span class="ot">&lt;-</span> mkEventSource
  network <span class="ot">&lt;-</span> compile <span class="fu">$</span> networkDescription input
  actuate network
  eventLoop input</code></pre></div>
<p>We use <code>compile</code> to create a <code>NetworkDescription</code> and <code>actuate</code> to get it kicking over. Most of our programs are going to do pretty similar things with respect to gluing things together, so it’s unlikely that we’ll delve too deeply into that last piece of code.</p>
<p>So far it’s not a very impressive event network, but it makes for a nice starting point.</p>
<h2 id="improvements-to-the-echo-program">Improvements to the echo program</h2>
<p>We can improve this program quite a bit.</p>
<h3 id="adding-the-ability-to-quit">Adding the ability to quit</h3>
<p>Let us start by adding the ability to quit the program when the user types “/quit”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess) 

<span class="ot">networkDescription ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription i <span class="fu">=</span> <span class="kw">do</span>
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> i

  <span class="kw">let</span>
    eMessage <span class="fu">=</span>       filterE (<span class="fu">/=</span> <span class="st">&quot;/quit&quot;</span>) eRead
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eRead

  reactimate <span class="fu">$</span> putStrLn <span class="fu">&lt;$&gt;</span> eMessage
  reactimate <span class="fu">$</span> exitSuccess <span class="fu">&lt;$</span> eQuit</code></pre></div>
<p>So far, so good.</p>
<h3 id="printing-a-message-on-exit">Printing a message on exit</h3>
<p>Now let’s say goodbye to the user before we go.</p>
<p>We’re going to introduce some helper functions here, to help deal with multiple non-simultaneous events. We know they’re non-simultaneous because they’re all going to be derived from <code>eRead</code>.</p>
<p>First we have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">orElse ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a
orElse <span class="fu">=</span> unionWith const</code></pre></div>
<p>which picks the first of two events if they are activated simultaneously.</p>
<p>We can extend that to a list of events with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">leftmost ::</span> [<span class="dt">Event</span> a] <span class="ot">-&gt;</span> <span class="dt">Event</span> a
leftmost <span class="fu">=</span> foldl orElse never</code></pre></div>
<p>which I tend to use more than <code>orElse</code>, since I tend to refactor FRP programs and it’s quicker to add or remove things from a list than it is to chain together a heap of events using <code>orElse</code>.</p>
<p>We’re using <code>never</code> in there, which is from <code>reactive-banana</code>, and is an event that never fires. It’s handy for things like the <code>leftmost</code>.</p>
<p>The change to print a message on exit is pretty small:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription i <span class="fu">=</span> <span class="kw">do</span>
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> i

  <span class="kw">let</span>
    eMessage <span class="fu">=</span>       filterE (<span class="fu">/=</span> <span class="st">&quot;/quit&quot;</span>) eRead
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eRead

  reactimate <span class="fu">$</span> fmap putStrLn <span class="fu">.</span> leftmost <span class="fu">$</span> [
      eMessage
    , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
    ]
  reactimate <span class="fu">$</span> exitSuccess <span class="fu">&lt;$</span> eQuit</code></pre></div>
<h3 id="refactoring-for-testing">Refactoring for testing</h3>
<p>There’s a tantalizing function available in <code>reactive-banana</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> (<span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Moment</span> (<span class="dt">Event</span> b)) <span class="ot">-&gt;</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Maybe</span> b] </code></pre></div>
<p>According to the haddocks, the IO is an implementation detail but you can otherwise treat it as a pure function.</p>
<p>Also in the haddocks for <code>interpret</code>: “Useful for testing.” That was like a red rag to a bull for me.</p>
<p>It looks like we’re going to need two data types to use it - one for our input events and one for our output events.</p>
<p>We’re up to the challenge:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">InputIO</span> <span class="fu">=</span>
  <span class="dt">Read</span> <span class="dt">String</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">OutputIO</span> <span class="fu">=</span>
    <span class="dt">Write</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">Close</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We want to be able to focus on the <code>String</code> in our <code>Read</code> inputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inputToRead ::</span> <span class="dt">Event</span> <span class="dt">InputIO</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">String</span>
inputToRead eIn <span class="fu">=</span>
    filterJust <span class="fu">$</span> maybeRead <span class="fu">&lt;$&gt;</span> eIn
  <span class="kw">where</span>
    maybeRead (<span class="dt">Read</span> x) <span class="fu">=</span> <span class="dt">Just</span> x
    maybeRead _        <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>This also introduces <code>filterJust</code>, which unwraps <code>Just</code> values in its input <code>Event</code> and ignores the <code>Nothing</code> values.</p>
<p>We can now define our event network.</p>
<p>Since we’re not doing any <code>IO</code> in the network, we can express it in the <code>Moment</code> monad rather than in the <code>MomentIO</code> monad. In fact even that is overkill, since what we currently want can be expressed as a pure function.</p>
<p>We’ll leave it in the <code>Moment</code> monad for now, since it means it is trivially compatible with <code>interpret</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myTestableNetwork ::</span> <span class="dt">Event</span> <span class="dt">InputIO</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> (<span class="dt">Event</span> [<span class="dt">OutputIO</span>])
myTestableNetwork eIn <span class="fu">=</span>
  <span class="kw">let</span>
    eRead    <span class="fu">=</span> inputToRead eIn
    eMessage <span class="fu">=</span>       filterE (<span class="fu">/=</span> <span class="st">&quot;/quit&quot;</span>) eRead
    eQuit    <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eRead

    eWrite   <span class="fu">=</span> leftmost [
        eMessage
      , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
      ]

    eOut <span class="fu">=</span> fmap (<span class="fu">$</span> []) <span class="fu">.</span> unions <span class="fu">$</span> [
        (\x xs <span class="ot">-&gt;</span> <span class="dt">Write</span> x <span class="fu">:</span> xs) <span class="fu">&lt;$&gt;</span> eWrite
      , (\xs <span class="ot">-&gt;</span> <span class="dt">Close</span> <span class="fu">:</span> xs) <span class="fu">&lt;$</span> eQuit
      ]
  <span class="kw">in</span>
    return eOut</code></pre></div>
<p>The biggest change here is with the description of <code>eOut</code>. We can’t use <code>leftmost</code> for this, since when the user quits we will have <code>eWrite</code> and <code>eQuit</code> happening at the same time. That’s why <code>eOut</code> has type <code>Event [OutputIO]</code>.</p>
<p>We build <code>eOut</code> using <code>unions</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unions ::</span> [<span class="dt">Event</span> (a <span class="ot">-&gt;</span> a)] <span class="ot">-&gt;</span> <span class="dt">Event</span> (a <span class="ot">-&gt;</span> a)</code></pre></div>
<p>If none of the input events activates, the output doesn’t activate. If only one of the input events activates with a value, the output activates with that value. If multiple inputs activate at the same time, the functions in the events are composed - with the functions being applied in the order they are listed - and the output activates with the composed function as the value.</p>
<p>This means that the listing of <code>eWrite</code> before <code>eQuit</code> is significant. If it were the other way around, our program would exit before it got to print its farewell.</p>
<p>Now we have something that we can test with <code>interpret</code>.</p>
<p>With some formatting liberties, we get:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> output <span class="ot">&lt;-</span> interpret myTestableNetwork [
    <span class="dt">Just</span> (<span class="dt">Read</span> <span class="st">&quot;one&quot;</span>)
  , <span class="dt">Nothing</span>
  , <span class="dt">Just</span> (<span class="dt">Read</span> <span class="st">&quot;two&quot;</span>)
  , <span class="dt">Just</span> (<span class="dt">Read</span> <span class="st">&quot;/quit&quot;</span>)
  ]
<span class="fu">&gt;</span> output
[ <span class="dt">Just</span> [<span class="dt">Write</span> <span class="st">&quot;one&quot;</span>]
, <span class="dt">Nothing</span>
, <span class="dt">Just</span> [<span class="dt">Write</span> <span class="st">&quot;two&quot;</span>]
, <span class="dt">Just</span> [<span class="dt">Write</span> <span class="st">&quot;Bye&quot;</span>, <span class="dt">Close</span>]
]</code></pre></div>
<p>which looks pretty handy for use with <code>QuickCheck</code> or <code>HUnit</code>.</p>
<p>In order to tie all of this together for actual usage we need to be able to convert our raw input events into events of type <code>Input</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleInput ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> (<span class="dt">Event</span> <span class="dt">InputIO</span>)
handleInput i <span class="fu">=</span> <span class="kw">do</span>
  eRead <span class="ot">&lt;-</span> fromAddHandler <span class="fu">.</span> addHandler <span class="fu">$</span> i
  return <span class="fu">$</span> <span class="dt">Read</span> <span class="fu">&lt;$&gt;</span> eRead</code></pre></div>
<p>and we need to be able to convert values of <code>Output</code> into <code>IO</code> actions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleOutput ::</span> <span class="dt">OutputIO</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
handleOutput (<span class="dt">Write</span> s) <span class="fu">=</span> putStrLn s
handleOutput <span class="dt">Close</span> <span class="fu">=</span> exitSuccess</code></pre></div>
<p>Our overall network is now split into setting up our inputs, a pure and testable network to convert inputs into outputs, and a dealing with outputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkDescription ::</span> <span class="dt">EventSource</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MomentIO</span> ()
networkDescription s <span class="fu">=</span> <span class="kw">do</span>
  i <span class="ot">&lt;-</span> handleInput s
  o <span class="ot">&lt;-</span> liftMoment <span class="fu">$</span> myTestableNetwork i
  reactimate <span class="fu">$</span> traverse_ handleOutput <span class="fu">&lt;$&gt;</span> o</code></pre></div>
<p>We use <code>liftMoment</code> here to convert our network in the <code>Moment</code> monad into a network in the <code>MomentIO</code> monad.</p>
<p>Voila! We have something that is both testable and usable.</p>
<h3 id="fanning-in-and-out">Fanning in and out</h3>
<p>Scratch that “Voila!” though, because the network is still a bit of a mess.</p>
<p>At the moment our event network has one event as input and one event as output.</p>
<div class="figure">
<img src="../images/network1.png" />

</div>
<p>That is mostly a side effect of the fact that we’re writing a command line application.</p>
<p>We can see a hint of that if we look at the way that we’re cramming two different outputs into <code>Output</code>. It is worth going further with this, in order to work out what the interesting events in our domain are.</p>
<p>If we untangle things it might help with reuse, it’ll give us smaller pieces that we can test, and it’ll force us to think about what our system is really doing.</p>
<p>In this case, I want to evolve this application into the back-end for a web-service, so when we get to there we’ll have different input events coming from different endpoints. This will be easier if we can tease out some more structure.</p>
<p>The first thing we can do is to identify our logical inputs and build a data structure to hold them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Inputs</span> <span class="fu">=</span> <span class="dt">Inputs</span> {
<span class="ot">    ieMessage        ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  ,<span class="ot"> ieQuit           ::</span> <span class="dt">Event</span> ()
  }</code></pre></div>
<p>We then build a function that will be the bridge between our actual inputs and our logical inputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fanOut ::</span> <span class="dt">Event</span> <span class="dt">InputIO</span> <span class="ot">-&gt;</span> <span class="dt">Inputs</span>
fanOut eIn <span class="fu">=</span>
  <span class="kw">let</span>
    eRead <span class="fu">=</span> inputToRead eIn
    eMessage <span class="fu">=</span> filterE (<span class="fu">/=</span> <span class="st">&quot;/quit&quot;</span>) eRead
    eQuit <span class="fu">=</span> () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;/quit&quot;</span>) eCommand
  <span class="kw">in</span>
    <span class="dt">Inputs</span> eMessage eQuit</code></pre></div>
<p>We’ll build a similar data structure for our logical outputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Outputs</span> <span class="fu">=</span> <span class="dt">Outputs</span> {
<span class="ot">    oeWrite ::</span> [<span class="dt">Event</span> <span class="dt">String</span>]
  ,<span class="ot"> oeClose ::</span> [<span class="dt">Event</span> ()]
  }</code></pre></div>
<p>and a function to bridge the gap:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fanIn ::</span> <span class="dt">Outputs</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> [<span class="dt">OutputIO</span>]
fanIn (<span class="dt">Outputs</span> eWrites eCloses) <span class="fu">=</span>
  <span class="kw">let</span>
    eCombinedWrites <span class="fu">=</span> fmap (\x xs <span class="ot">-&gt;</span> <span class="dt">Write</span> x <span class="fu">:</span> xs) <span class="fu">&lt;$&gt;</span> eWrites
    eCombinedCloses <span class="fu">=</span> [(<span class="dt">Close</span> <span class="fu">:</span>) <span class="fu">&lt;$</span> leftmost eCloses]
  <span class="kw">in</span>
    fmap (<span class="fu">$</span> []) <span class="fu">.</span>
    unions <span class="fu">$</span>
    eCombinedWrites <span class="fu">++</span> eCombinedCloses</code></pre></div>
<p>We’re dealing with multiple write events already, and it seems likely we’ll end up with multiple close events, so <code>Outputs</code> contains lists for both of these.</p>
<p>We also want to be doing the combining of these in <code>fanIn</code> rather than in our event network, since knowing how to combine them is something that involves information about both the logical and actual domains. You can see that in action in the code - we combine all of our write events by append them together, because we want all of the writes to happen, but we just use the leftmost close event, since we only want to close the application at most once.</p>
<p>We end up with a network that looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myLogicalNetwork ::</span> <span class="dt">Inputs</span> <span class="ot">-&gt;</span> <span class="dt">Outputs</span>
myLogicalNetwork (<span class="dt">Inputs</span> eMessage eQuit) <span class="fu">=</span>
  <span class="kw">let</span>
    eWrites <span class="fu">=</span> [
        eMessage
      , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
      ]
    eQuits <span class="fu">=</span> [
        eQuit
      ]
  <span class="kw">in</span>
    <span class="dt">Outputs</span> eWrites eQuits

<span class="ot">myTestableNetwork ::</span> <span class="dt">Event</span> <span class="dt">InputIO</span> <span class="ot">-&gt;</span> <span class="dt">Moment</span> (<span class="dt">Event</span> [<span class="dt">OutputIO</span>])
myTestableNetwork <span class="fu">=</span>
  return <span class="fu">.</span> fanIn <span class="fu">.</span> myLogicalNetwork <span class="fu">.</span> fanOut</code></pre></div>
<p>which is a bit underwhelming.</p>
<p>If we draw a block diagram for the system though, we’ve exposed a bit more of what is going on:</p>
<div class="figure">
<img src="../images/network2.png" />

</div>
<p>It is worth pointing out that as an aside that we can test our <code>fanOut</code> component with <code>interpret</code> by introducing a new data type to collect the results:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FanOutResults</span> <span class="fu">=</span>
    <span class="dt">FrMessage</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">FrQuit</span>

<span class="ot">collectFanOutResults ::</span> <span class="dt">Inputs</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> <span class="dt">FanOutResults</span>
collectFanOutResults (<span class="dt">Inputs</span> eMessage eQuit _) <span class="fu">=</span>
  leftmost [
      <span class="dt">FrMessage</span> <span class="fu">&lt;$&gt;</span> eMessage
    , <span class="dt">FrQuit</span> <span class="fu">&lt;$</span> eQuit
    ]</code></pre></div>
<h3 id="handling-unknown-commands">Handling unknown commands</h3>
<p>On the topic of the <code>fanOut</code> function, we should make some changes to help prepare for the future.</p>
<p>We’re going to treat all input strings that start with “/” as commands, and we want to reject any commands that we don’t recognize or are otherwise ill-formed. We’ll also ignore empty strings that are input.</p>
<p>We’ll need a new event in <code>Inputs</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Inputs</span> <span class="fu">=</span> <span class="dt">Inputs</span> {
<span class="ot">    ieMessage        ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  ,<span class="ot"> ieQuit           ::</span> <span class="dt">Event</span> ()
  ,<span class="ot"> ieUnknownCommand ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  }</code></pre></div>
<p>Our new version of <code>fanOut</code> looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fanOut ::</span> <span class="dt">Event</span> <span class="dt">InputIO</span> <span class="ot">-&gt;</span> <span class="dt">Inputs</span>
fanOut eIn <span class="fu">=</span>
  <span class="kw">let</span>
    eRead <span class="fu">=</span>
      filterE (not <span class="fu">.</span> null) <span class="fu">$</span> inputToRead eIn

    isMessage <span class="fu">=</span>
      (<span class="fu">/=</span> <span class="st">&quot;/&quot;</span>) <span class="fu">.</span> take <span class="dv">1</span>
    eMessage <span class="fu">=</span>
      filterE isMessage eRead

    isCommand <span class="fu">=</span>
      (<span class="fu">==</span> <span class="st">&quot;/&quot;</span>) <span class="fu">.</span> take <span class="dv">1</span>
    eCommand <span class="fu">=</span>
      fmap (drop <span class="dv">1</span>) <span class="fu">.</span> filterE isCommand <span class="fu">$</span> eRead

    eQuit <span class="fu">=</span>
      () <span class="fu">&lt;$</span> filterE (<span class="fu">==</span> <span class="st">&quot;quit&quot;</span>) eCommand
    eUnknownCommand <span class="fu">=</span>
      filterE (<span class="fu">/=</span> <span class="st">&quot;quit&quot;</span>) eCommand
  <span class="kw">in</span>
    <span class="dt">Inputs</span> eMessage eQuit eUnknownCommand</code></pre></div>
<p>and is starting to exhibit some of the wall-of-text characteristics that you come across in FRP code.</p>
<p>If you wanted to enhance that effect, you could inline <code>isMessage</code> and <code>isCommand</code> into the definitions of <code>eMessage</code> and <code>eCommand</code> respectively.</p>
<p>To go in the other direciton we could do change to a two stage approach, with the first stage filtering out empty inputs and splitting messages from other commands, and the second stage handling the commands themselves.</p>
<p>The change that the new event has on our network is fairly small:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myLogicalNetwork ::</span> <span class="dt">Inputs</span> <span class="ot">-&gt;</span> <span class="dt">Outputs</span>
myLogicalNetwork (<span class="dt">Inputs</span> eMessage eQuit eUnknownCommand) <span class="fu">=</span>
  <span class="kw">let</span>
    eWrites <span class="fu">=</span> [
        eMessage
      , <span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit
      , (<span class="st">&quot;Unknown command: &quot;</span> <span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> eUnknownCommand
      ]
    eQuits <span class="fu">=</span> [
        eQuit
      ]
  <span class="kw">in</span>
    <span class="dt">Outputs</span> eWrites eQuits</code></pre></div>
<p>which is usually a good sign.</p>
<h3 id="breaking-things-down-even-more">Breaking things down even more</h3>
<p>The last change I want to play with is adding a component for each of the commands we want to handle.</p>
<p>Some of the FRP examples end up with pretty big event network all defined in the one place. That can be fine once you’re up to speed and now what you’re doing. One thing I took away from the Manning Functional Reactive Programming book was that you can clarify things a great deal by creating data types for the inputs and outputs of your logical components and pulling out the description of how the inputs relate to the outputs out of the main event network.</p>
<p>It might look like overkill, but you can always use fewer components with more going on inside each one.</p>
<p>We have a pair of data types for handling messages, and a function to get from one to the other:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MessageInput</span> <span class="fu">=</span> <span class="dt">MessageInput</span> {
<span class="ot">    mieRead ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  }

<span class="kw">data</span> <span class="dt">MessageOutput</span> <span class="fu">=</span> <span class="dt">MessageOutput</span> {
<span class="ot">    moeWrite ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  }

<span class="ot">handleMessage ::</span> <span class="dt">MessageInput</span> <span class="ot">-&gt;</span> <span class="dt">MessageOutput</span>
handleMessage (<span class="dt">MessageInput</span> eMessage) <span class="fu">=</span>
  <span class="dt">MessageOutput</span> eMessage</code></pre></div>
<p>We have the same arrangement for handling the command to quit:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">QuitInput</span> <span class="fu">=</span> <span class="dt">QuitInput</span> {
<span class="ot">    qieQuit ::</span> <span class="dt">Event</span> ()
  }

<span class="kw">data</span> <span class="dt">QuitOutput</span> <span class="fu">=</span> <span class="dt">QuitOutput</span> {
<span class="ot">    qoeWrite ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  ,<span class="ot"> qoeQuit  ::</span> <span class="dt">Event</span> ()
  }

<span class="ot">handleQuit ::</span> <span class="dt">QuitInput</span> <span class="ot">-&gt;</span> <span class="dt">QuitOutput</span>
handleQuit (<span class="dt">QuitInput</span> eQuit) <span class="fu">=</span>
  <span class="dt">QuitOutput</span> (<span class="st">&quot;Bye&quot;</span> <span class="fu">&lt;$</span> eQuit) eQuit</code></pre></div>
<p>which encapsulates our farewell message rather than leaving it hanging out in the middle of our event network.</p>
<p>Unknown commands get a similar treatment:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">UnknownCommandInput</span> <span class="fu">=</span> <span class="dt">UnknownCommandInput</span> {
<span class="ot">    ucieUnknownCommand ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  }

<span class="kw">data</span> <span class="dt">UnknownCommandOutput</span> <span class="fu">=</span> <span class="dt">UnknownCommandOutput</span> {
<span class="ot">    ucoeUnknownCommand ::</span> <span class="dt">Event</span> <span class="dt">String</span>
  }

<span class="ot">handleUnknownCommand ::</span> <span class="dt">UnknownCommandInput</span> <span class="ot">-&gt;</span> <span class="dt">UnknownCommandOutput</span>
handleUnknownCommand (<span class="dt">UnknownCommandInput</span> eUnknownCommand) <span class="fu">=</span>
  <span class="dt">UnknownCommandOutput</span> ((<span class="st">&quot;Unknown command: &quot;</span> <span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> eUnknownCommand )</code></pre></div>
<p>Our network that uses these pieces looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myLogicalNetwork ::</span> <span class="dt">Inputs</span> <span class="ot">-&gt;</span> <span class="dt">Outputs</span>
myLogicalNetwork (<span class="dt">Inputs</span> eMessage eQuit eUnknownCommand) <span class="fu">=</span>
  <span class="kw">let</span>
    <span class="dt">MessageOutput</span> emWrite <span class="fu">=</span> handleMessage <span class="fu">$</span> <span class="dt">MessageInput</span> eMessage
    <span class="dt">QuitOutput</span> eqWrite eqQuit <span class="fu">=</span> handleQuit <span class="fu">$</span> <span class="dt">QuitInput</span> eQuit
    <span class="dt">UnknownCommandOutput</span> eucWrite <span class="fu">=</span> handleUnknownCommand <span class="fu">$</span> <span class="dt">UnknownCommandInput</span> eUnknownCommand
  <span class="kw">in</span>
    <span class="dt">Outputs</span> [emWrite, eqWrite, eucWrite] [eqQuit]</code></pre></div>
<p>with a block diagram that looks like this:</p>
<div class="figure">
<img src="../images/network3.png" />

</div>
<h2 id="next-time">Next time…</h2>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on September  1, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
